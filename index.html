<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>HunnyPotr by Recce7 by RECCE7</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">HunnyPotr by Recce7</h1>
      <h2 class="project-tagline">Technical Documentation For The Easily Extensible Honey Pot</h2>
    </section>

    <section class="main-content">
      <h1>
<a id="purpose-of-project" class="anchor" href="#purpose-of-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Purpose of Project</h1>
<p>Create an easy-install honey pot that any Security Engineer or Systems Administrator can easily write custom plugins for applications or services running on their network.  The honey pot needs to display critical data to the user in an easy to read and navigate format.  This tool is useful to show what kind of attacks are going on and verify that the actual services are guarded appropriately.</p>

<h1>
<a id="features-and-libraries-used" class="anchor" href="#features-and-libraries-used" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Features and Libraries Used</h1>

<h3>
<a id="designed-to-run-on-raspberrypi-zero" class="anchor" href="#designed-to-run-on-raspberrypi-zero" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Designed to Run on <a href="https://www.raspberrypi.org/products/pi-zero/">RaspberryPi Zero</a>
</h3>

<p>Application built around running on a RaspberryPi Zero to make it easy to deploy in any physical environment as well as being cost efficient.  Packages for both <a href="https://www.debian.org/">Debian</a> and <a href="https://www.centos.org/">CentOS</a> available to increase flexibility for users.</p>

<h3>
<a id="displaying-reporting-data-with-grafana" class="anchor" href="#displaying-reporting-data-with-grafana" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Displaying Reporting Data with <a href="http://grafana.org/">Grafana</a>
</h3>

<p>HoneyPotR will come packaged with some basic graphs and output configured by default. This allows any user to get up and running with HoneyPotR quickly by providing pre-built graphs so that information can be displayed for real-time attacks immediately.  Grafana also makes it very easy to build your own graphs in order to display any metrics that fit your needs.
<img src="recce7.github.io/images/grafana1.png" alt="">
<img src="recce7.github.io/images/grafana2.png" alt=""></p>

<h3>
<a id="using-docker-for-builds-and-ci-management" class="anchor" href="#using-docker-for-builds-and-ci-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using <a href="https://www.docker.com/">Docker</a> for Builds and CI Management</h3>

<p>Docker makes it easy to develop, test, build and manage a Continuous Integration development cycle.  By using Docker we have given our clients the ability to run HoneyPotR on any platform.  If running a Raspberry Pi does no fit your needs, Docker allows you to run our Debian and CentOS packages on any system such as Microsoft and Apple OS X.  Docker can also be used to deploy Grafana on a machine other than the Raspberry Pi.</p>

<h3>
<a id="passive-os-fingerprinting-with-p0f" class="anchor" href="#passive-os-fingerprinting-with-p0f" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Passive OS Fingerprinting with <a href="http://lcamtuf.coredump.cx/p0f3/">P0f</a>
</h3>

<p>By passively listening to the TCP Handshake between our honey pot and the attacker we are able to pull the following data:</p>

<ul>
<li>Time that the attacker connected and disconnected</li>
<li>Amount of connections the attacker currently has on HoneyPotR</li>
<li>Detected remote Operating System, version and accuracy estimated system</li>
<li>HTTP Client if available, i.e. browser, version and user agent; curl version; wget version</li>
<li>Network Link</li>
<li>Distance, amount of hops made to reach HoneyPotR</li>
<li>Language</li>
<li>Uptime</li>
</ul>

<h3>
<a id="geoip" class="anchor" href="#geoip" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Geoip</h3>

<p>Using a simple cURL call to <a href="http://ipinfo.io">ipinfo.io</a> we are able to gather useful information regarding the location of the attacker and the type of service they may be using.  We are then mapping the information from this call to a world map that is able to display the location of all attacks made on HoneyPotR.  This world map is accessible via an endpoint in HoneyPotR's REST API so that a user is able to pass a days GET parameter to narrow down the amount of points showing on the map.</p>

<h3>
<a id="rest-api" class="anchor" href="#rest-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REST API</h3>

<p>Users will have access to reporting data through a RESTful API.  Attack data resources are represented as JSON Arrays which makes it easy to narrow down and display exactly what information a user may want to access using HTTP GET calls.  This API allows flexibility for our clients to get reporting data however fits best for their environment.  For example if a client already had a GUI for reporting traffic on their network it would be easy for them to make calls to HoneyPotR via the REST API without the need to use Grafana.</p>

<h1>
<a id="how-it-works" class="anchor" href="#how-it-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How It Works</h1>

<h2>
<a id="framework" class="anchor" href="#framework" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Framework</h2>

<p>The framework class is responsible for managing the flow of information throughout the system.  Once the application is started the framework will initiate a <em>NetworkListener</em> that will attempt to complete the TCP handshake of any SYN packets that are addressed to the machine HoneyPotR is running on.  Once this handshake is complete, the framework is able to determine which plug-in is being called based on the port number set in the configuration.  As the plug-in is running and recording data, it is being passed back down to the framework which then passes it on to the <em>DataManager</em>.</p>

<p>The framework is also responsible for handling the multi-threaded nature of our application, the safe and graceful shutdown of the application and all current connections.  Multiple threads are needed to ensure that each running plug-in is able to handle connections from multiple attackers at once while being able to simultaneously write the data that is being collected from the malicious actor.  It is also imperative that HoneyPotR is able to gracefully close all running connections so that no data is lost before it is written.  In the case that the application is compromised we need to shutdown gracefully so that we can end the threat without losing data collected up to that point.</p>

<h2>
<a id="plug-ins" class="anchor" href="#plug-ins" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Plug-ins</h2>

<p>Each plug-in should be developed to match services running in production as closely as possible.  HoneyPotR comes with Telnet and HTTP servers by default.  Both include interfaces in which the attacker can interact with that will record all of the attackers commands.  By including these plug-ins we give our users an example of how to develop their own services, as well as the ability to collect data while developing their own.</p>

<p>The default plug-ins are also able to handle scans from popular network scanners such as <a href="https://nmap.org">Nmap</a>.  It is common for attacks to start with scans so that the hacker will have an understanding of what services are running on the network.  The ability to capture and record these scans will give us an idea of what kind of information the attacker is looking to gain before going active with his attack.</p>

<h2>
<a id="data-management" class="anchor" href="#data-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data Management</h2>

<p>HoneyPotR uses <a href="https://www.sqlite.org/">Sqlite3</a> which comes embedded in <a href="https://www.python.org/download/releases/3.0/">Python3</a>.  This made creating a persistant database, that we store locally, easy and lightweight.  All of the data management logic resides in the <code>database</code> directory which contains modules and classes used by the framework to create, modify and insert data into the database. The resulting database is then used by the report server to query data for reporting.</p>

<p>There are two types of tables defined within the system. User defined tables are those tables that users may create columns in for the storing of specific plug-in data. Non-User defined tables are created by various SQL scripts and should not to be altered by plug-in authors. These Non-User defined tables are the ipInfo, p0f and sessions tables.</p>

<p>The <strong>DataManager</strong> is instantiated by the Framework and has access to the global configuration defined in <code>common/config/globals.cfg</code>. The DataManager makes use of this information to both create non-existent tables and to update table definitions in the database by checking the difference between the current schema and the database configuration defined by the plug-in author.  The DataManager also has access to a <strong>DataValidator</strong> class which checks that the data to be inserted is well formed.  The <strong>DataQueue</strong> class contains a Python queue (FIFO) along with some other methods for standard queue operations.  The DataManager gets items from this queue and inserts them to the database.  This method of writing data allows us the ability to write data from the plug-ins without the need to keep those connections open waiting for the database to unlock from other write operations.  To ensure that we do not lose in information in the queue the Framework ensures the queue is empty before shutting down the data management system.</p>

<h3>
<a id="datamanager-class" class="anchor" href="#datamanager-class" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DataManager Class</h3>

<p>The DataManager Class is called by the framework within its start method. The DataManager creates an instance of <strong>Database</strong> so that it can call the  <code>create_default_database</code> method and create the initial database or modify the existing database with updates to the user defined configurations between this run and the previous run of the program. The DataManager then creates the DataQueue object that will be used to store database transactions until the thread can process them by acquiring a condition variable.</p>

<p>When the Framework calls the DataManager's <code>start</code> method the DataManager's <code>run</code> method will be invoked. This run method will check to see if the queue is empty and then the thread will wait, this will release the lock on the condition variable and block until it is called by notify on that same condition variable.</p>

<p>When the Framework calls DataManager <code>insert_data method</code> this method will acquire the condition variable and call the Queue's <code>insert_into_data_queue</code> method and will then <code>notify</code> the condition variable telling the run method to continue checking the queue for data to insert. Once the queue is empty the run method will again wait for another notification from the <code>insert_data</code> method. The DataManager also contains a <code>shutdown</code> method that will shut down the thread.</p>

<h3>
<a id="database-class-and-table-init-module" class="anchor" href="#database-class-and-table-init-module" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Database Class and Table Init Module</h3>

<p>The <strong>Database</strong> class will create the directory for storing the database itself as well as creating the database file. It will also execute any scripts for creating Non-User defined tables within that database. Finally it will execute the <code>update_schema</code> method that will in turn create and/or update any user defined definitions based on plug-in configuration.  This class interacts with the <strong>Table_Init</strong> module to: </p>

<ul>
<li>Create tables and indexes</li>
<li>Modify existing table definitions</li>
<li>Verify that defined columns are valid sqlite3 data types</li>
</ul>

<p>Currently when a user-defined plug-in table is redefined in the plug-in configuration that table will be effectively truncated in order to add or remove the columns defined. In the future it would be good to implement the redefinition in a way that keeps what data is possible to persist between redefinitions.</p>

<h3>
<a id="datavalidator-class" class="anchor" href="#datavalidator-class" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DataValidator Class</h3>

<p>The DataValidator class is responsible for checking upon insert into the DataQueue that the data that is being inserted is well formed for the database. The DataValidator has access to the schema currently stored in the database. By pulling this schema out of the database it can be used to assist with data validation.  Currently the DataValidator has check methods for the following:</p>

<ul>
<li>
<strong>check_value_len:</strong>  This method checks that there is exactly 1 table being written to per insert into the data queue</li>
<li>
<strong>check_value_is_dict:</strong> This method checks that the value for insertion is of type dictionary.</li>
<li>
<strong>check_key_in_dict_string:</strong> This method checks that the first and only key in the insert dictionary is a string (this key signifies the table name for insertion)</li>
<li>
<strong>check_key_is_valid_table_name:</strong> This method checks that the key for the insertion dictionary is actually a table name in the database.</li>
<li>
<strong>check_row_value_is_dict:</strong> This method checks that the row values (column: values) of the dictionary provided for insertion is itself a dictionary. For example: {'table1':{'column1':'value1'}}</li>
<li>
<strong>check_all_col_names_strings:</strong> This method checks that all the column names to be inserted are strings.</li>
<li>
<strong>check_all_col_exist:</strong> This method checks that all the column names provided exist in the target table.</li>
<li>
<strong>check_data_types:</strong> <em>Not implemented yet</em> Intended to examine all column values for insertion and to validate against legal regular expressions for the data types we intend to store in the table.</li>
</ul>

<p>If all checks in the validator do not pass then the value will not be inserted into the DataQueue. Any check errors will be logged to the <code>recce7.log</code> file explaining why that data was not allowed into the data queue. These errors can be useful for plug-in authors when designing a table for their plug-ins.</p>

<h3>
<a id="dataqueue-class" class="anchor" href="#dataqueue-class" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DataQueue Class</h3>

<p>The DataQueue class simply creates a python Queue and instantiates the DataValidator class. The method <code>insert_into_data_queue</code> is called by the DataManager to insert data into the python Queue. This insert_into_data_queue method runs all the checks provided in the data validator prior to inserting the dictionary into the Queue.  The DataQueue also provides helper methods for <code>get_next_item</code> and <code>check_emtpy</code>.</p>

<h3>
<a id="table-insert-module" class="anchor" href="#table-insert-module" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Table Insert Module</h3>

<p>The Table_Insert module provides methods to insert the data from the DataQueue into the database itself.  Because the name-value pairs in the insert dictionary represent the column names and their values it is necessary to prepare the data for insertion.
The following methods are available in the Table Insert Module:</p>

<ul>
<li>
<code>prepare_data_for_insertion</code> orders the values prior to insertion so that the appropriate value goes with the appropriate field in its table</li>
<li>
<code>prepare_data_for_insertion</code> also pulls the session information from the plug-in table insert request for storage in the sessions table (if provided) for session grouping visibility</li>
<li>
<code>prepare_data_for_insertion</code> also decides whether or not to insert or update data in the p0f (finger printing table) and whether or not to insert a new row in the ipInfo table</li>
<li>
<code>insert_data</code> joins the ordered values provided together into a SQL insert statement and inserts data into the sessions table if provided</li>
<li>
<code>update_data</code> method constructs a SQL update statement based on a where clause provided. This is currently only used in the p0f preparation because we need the most recent fingerprinting stored with the session in that table instead of a new row if the information changes.</li>
</ul>

<h3>
<a id="util-module" class="anchor" href="#util-module" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Util Module</h3>

<p>The util module contains some common methods used throughout the database code and the configuration for the default columns that are standard for all plug-in tables.  These default columns are pre-pended to all plug-in tables regardless of the extended definitions that the plug-in authors provide therefore are not defined in the plug-ins' configurations file.
The default columns:</p>

<ul>
<li>
<strong>ID :</strong> A sequential primary key and is managed (not passed in by the plug-in) by the database</li>
<li>
<strong>session :</strong> A field to associate multiple calls or commands to a given plug-in with each other, if this value is not provided then no rows will be inserted into the sessions table</li>
<li>
<strong>eventDateTime :</strong> A field to store the time stamp when the plug-in creates its insert dictionary</li>
<li>
<strong>peerAddress :</strong> A field to store the attackers ip address, provided by the plug-in author</li>
<li>
<strong>localAddress :</strong> A field to store the local address of the machine the plug-in is running on</li>
</ul>

<h2>
<a id="data-reporting" class="anchor" href="#data-reporting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data Reporting</h2>

<p>As mentioned in the features section we provide a REST API to allow users to integrate data from our reporting server to their own user interface systems.</p>

<h3>
<a id="setup-restful-report-server" class="anchor" href="#setup-restful-report-server" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setup RESTful Report Server</h3>

<ul>
<li>Navigate to the directory where HoneyPotR was installed</li>
<li>Edit the <code>global.cfg</code> file located in <code>./config/</code> so that the Database <code>path</code> points to where the database is installed, note the example below:</li>
</ul>

<pre><code>[Database]
path = honeyDB/honeyDB.sqlite
datetime.name = eventDateTime
peerAddress.name = peerAddress
localAddress.name = localAddress
</code></pre>

<ul>
<li>Locate the ReportServer section and edit properties to fit your needs, note the example below:</li>
</ul>

<pre><code>[ReportServer]
reportserver.logName = reportserver.log
reportserver.logLevel = DEBUG
reportserver.host = 192.168.1.16
reportserver.port = 8080
</code></pre>

<ul>
<li>To start the report server navigate back to the installed directory and run <code>sudo ./startReportingServer.sh</code>
</li>
</ul>

<h3>
<a id="using-rest-api" class="anchor" href="#using-rest-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using REST API</h3>

<p>All responses will return content-type: application/json
All examples below assume report server configured to respond on <code>localhost</code> and port <code>8080</code></p>

<h4>Analytics Endpoint</h4>
<p><code>GET http://{REPORT SERVER HOST}/v1/analytics</code></p>
<table>
  <tr><td><strong>Response Headers</strong></td><td>Content-Type --application/json</td></tr>
  <tr><td><strong>Status Codes</strong></td><td>200 OK - Request completed successfully</td></tr>
  <tr><td><strong>Request</strong></td><td>http://localhost:8080/v1/analytics</td></tr>
  <tr><td><strong>Response</strong></td><td>
    {
      "links": [
          "rel: ports, href: http://127.0.0.1:8080/v1/analytics/ports",
          "rel: ipaddresses, href:http://127.0.0.1:8080/v1/analytics/ipaddresses"
      ]
    }</td></tr>
</table>

<h4>Ports Endpoint</h4>
<p><code>GET http://{REPORT SERVER HOST}/v1/analytics/ports</code></p>
<p>Returns a list of enabled ports and their data.  If the port was marked disabled in the configuration, it will not show up in this response.  Default of the data in the response is timespan of 1 day, unless otherwise specified.</p>
<table>
  <tr><td><strong>Response Headers</strong></td><td>Content-Type --application/json</td></tr>
  <tr><td><strong>Status Codes</strong></td><td>200 OK - Request completed successfully</td></tr>
  <tr><td><strong>Request</strong></td><td>http://localhost:8080/v1/analytics/ports</td></tr>
  <tr><td><strong>Optional Parameters</strong></td><td><br class="small">?minutes=xx</br><br class="small">?hours=xx</br><br class="small">?days=xx</br><br class="small">?weeks=xx</br><br class="small">Example: http://localhost:8080/v1/analytics/ports/8023?days=100</br>
  <tr><td><strong>Response</strong></td><td>
    [
        {
            "timespan": "days=1",
            "rel_link": "http://127.0.0.1:8080/v1/analytics/ports/8082?days=1",
            "total_attacks": "0",
            "port": "8082",
            "unique_ipaddresses": "0"
        },
        {
            "timespan": "days=1",
            "rel_link": "http://127.0.0.1:8080/v1/analytics/ports/8083?days=1",
            "total_attacks": "0",
            "port": "8083",
            "unique_ipaddresses": "0"
        },
        {
            "timespan": "days=1",
            "rel_link": "http://127.0.0.1:8080/v1/analytics/ports/8023?days=1",
            "total_attacks": "0",
            "port": "8023",
            "unique_ipaddresses": "0"
        }
    ]
  </td></tr>
</table>

<h4>Ports Endpoint : Specify Port Number</h4>
<p><code>GET http://{REPORT SERVER HOST}/v1/analytics/ports/{PORT NUMBER}</code></p>
<p>Returns details of attacks for given port.  Default of the data in the response is timespan of 1 day, unless otherwise specified.</p>
<table>
  <tr><td><strong>Response Headers</strong></td><td>Content-Type --application/json</td></tr>
  <tr><td><strong>Status Codes</strong></td><td>200 OK - Request completed successfully</td></tr>
  <tr><td><strong>Request</strong></td><td>http://localhost:8080/v1/analytics/ports/8023</td></tr>
  <tr><td><strong>Optional Parameters</strong></td><td><br class="small">?minutes=xx</br><br class="small">?hours=xx</br><br class="small">?days=xx</br><br class="small">?weeks=xx</br><br class="small">Example: http://localhost:8080/v1/analytics/ports/8023?days=100</br>
  <tr><td><strong>Response</strong></td><td>
    {
        "timespan": "days=100",
        "port": "8082",
        "items": [
            {
                "duration": "22:02:33.477883",
                "end_time": "2016-04-24T14:14:18.991806",
                "session_items": [
                    {
                        "peerAddress": "127.0.0.1",
                        "localAddress": "127.0.0.1",
                        "path": "/login",
                        "ID": 1,
                        "headers": "Host: localhost:8082\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36\nDNT: 1\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-US,en;q=0.8\nCookie: SESSION=d60718da-e011-4d80-88a2-c745b7af8fd2\n\n",
                        "eventDateTime": "2016-04-23T16:11:45.513923",
                        "command": "GET",
                        "session": "d60718da-e011-4d80-88a2-c745b7af8fd2",
                        "body": ""
                    },
                ]
              }
        ]
    }
  </td></tr>
</table>

<h4>IP Addresses Endpoint</h4>
<p><code>GET http://{REPORT SERVER HOST}/v1/ipaddresses</code></p>
<p>Future release</p>

<h4>IP Addresses Endpoint : Specify IP Address</h4>
<p><code>GET http://{REPORT SERVER HOST}/v1/ipaddresses/{VALID IP ADDRESS}</code></p>
<p>Returns details of attacks for each enabled port that the IP address attempted to access.  Default of the data in the response is timespan of 1 day, unless otherwise specified.</p>
<table>
  <tr><td><strong>Response Headers</strong></td><td>Content-Type --application/json</td></tr>
  <tr><td><strong>Status Codes</strong></td><td>200 OK - Request completed successfully</td></tr>
  <tr><td><strong>Request</strong></td><td>http://localhost:8080/v1/ipaddress/127.0.0.1</td></tr>
  <tr><td><strong>Optional Parameters</strong></td><td><br class="small">?minutes=xx</br><br class="small">?hours=xx</br><br class="small">?days=xx</br><br class="small">?weeks=xx</br><br class="small">Example: http://localhost:8080/v1/analytics/ipaddresses/127.0.0.1?days=100</br>
  <tr><td><strong>Response</strong><p>Example of no attacks</p></td><td>
    {
        "timespan": "days=1",
        "ipaddress": "127.0.0.1",
        "ports": [
            {
                "8082": []
            },
            {
                "8083": []
            },
            {
                "8023": []
            }
        ]
    }
  </td></tr>
  <tr><td><strong>Response</strong><p>Example with attacks</p></td><td>
    {
        "timespan": "days=10",
        "ipaddress": "127.0.0.1",
        "ports": [
            {
                "8082": [
                    {
                        "duration": "22:02:33.477883",
                        "end_time": "2016-04-24T14:14:18.991806",
                        "session_items": [
                            {
                                "peerAddress": "127.0.0.1",
                                "localAddress": "127.0.0.1",
                                "path": "/login",
                                "ID": 1,
                                "headers": "Host: localhost:8082\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36\nDNT: 1\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-US,en;q=0.8\nCookie: SESSION=d60718da-e011-4d80-88a2-c745b7af8fd2\n\n",
                                "eventDateTime": "2016-04-23T16:11:45.513923",
                                "command": "GET",
                                "session": "d60718da-e011-4d80-88a2-c745b7af8fd2",
                                "body": ""
                            },
                            
                        ],
                        "peer_address": "127.0.0.1",
                        "session": "d60718da-e011-4d80-88a2-c745b7af8fd2",
                        "local_address": "127.0.0.1",
                        "begin_time": "2016-04-23T16:11:45.513923"
                    },
                    
            },
            {
                "8083": [
                    {
                        "duration": "22:03:37.946130",
                        "end_time": "2016-04-24T14:15:11.759311",
                        "session_items": [
                            {
                                "peerAddress": "127.0.0.1",
                                "localAddress": "127.0.0.1",
                                "path": "/",
                                "ID": 7,
                                "headers": "Host: localhost:8083\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36\nDNT: 1\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-US,en;q=0.8\nCookie: SESSION=d60718da-e011-4d80-88a2-c745b7af8fd2\n\n",
                                "eventDateTime": "2016-04-23T16:11:33.813181",
                                "command": "GET",
                                "session": "d60718da-e011-4d80-88a2-c745b7af8fd2",
                                "body": ""
                            },
                            
                        ],
                        "peer_address": "127.0.0.1",
                        "session": "d60718da-e011-4d80-88a2-c745b7af8fd2",
                        "local_address": "127.0.0.1",
                        "begin_time": "2016-04-23T16:11:33.813181"
                    },
                    
            },
            {
                "8023": [
                    {
                        "duration": "0:00:06.704076",
                        "end_time": "2016-04-23T16:12:27.201369",
                        "session_items": [
                            {
                                "peerAddress": "127.0.0.1",
                                "localAddress": "127.0.0.1",
                                "user_input": "hellow",
                                "ID": 1,
                                "eventDateTime": "2016-04-23T16:12:20.497293",
                                "session": "f6cae8f0-5c61-4319-b357-1dcc20ab6fe4",
                                "input_type": "username"
                            },
                            
                        ],
                        "peer_address": "127.0.0.1",
                        "session": "6c83a4ae-f32c-442d-a545-f0accd735d99",
                        "local_address": "127.0.0.1",
                        "begin_time": "2016-04-23T16:12:42.440673"
                    }
                ]
            }
        ]
    }
  </td></tr>
</table>

<h4>WorldMap Endpoint</h4>
<p><code>GET http://{REPORT SERVER HOST}/v1/worldmap</code></p>
<p>Returns an image map of the location of the ipaddresses. Can scope data by minutes, hours, days, weeks.  If no data scope is given, it defaults to days=1.</p>
<table>
  <tr><td><strong>Response Headers</strong></td><td>Content-Type --application/json</td></tr>
  <tr><td><strong>Status Codes</strong></td><td>200 OK - Request completed successfully</td></tr>
  <tr><td><strong>Request</strong></td><td>http://{REPORT SERVER HOST}/v1/worldmap?days=10</td></tr>
  <tr><td><strong>Optional Parameters</strong></td><td><br class="small">?days=xx</br><br class="small">Example: http://localhost:8080/v1/analytics/ports/8023?days=100</br>
  <tr><td><strong>Response</strong></td><td>
    <p>A global map with plots of attacks will displayed in browser when this endpoint is called.</p>
  </td></tr>
</table>


<h2>
<a id="setup-grafana-reporting-graphs-and-boards" class="anchor" href="#setup-grafana-reporting-graphs-and-boards" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setup Grafana Reporting Graphs and Boards</h2>

<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>

<h1>
<a id="how-to-install-and-run-hunnypotr" class="anchor" href="#how-to-install-and-run-hunnypotr" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How to Install and Run HunnyPotR</h1>

<p>These instructions will walk you through installing and running HunnyPotR/Recce7 on a Raspberry Pi Zero. 
It is strongly recommended that your Raspberry Pi have at least 4GB of available storage, particularly if you would
like to generate attacker worldmaps (see "Installing Basemap" below).</p>

<p>These instructions are intended for the Raspbian OS as this is currently the only modern Linux OS available for Raspberry Pi hardware.
Similar instructions will work on most Debian-derived Linux distributions on x86, ARM or other platforms.</p>

<p>These directions assume that you are starting with a fresh installation of Raspbian and that you are working from a shell in the default user's home directory (<tt>/home/pi/</tt>).</p>

<p>Before beginning, ensure your Raspbian package repositories are up-to-date:</p>
<blockquote>
  <pre>$ sudo apt-get update</pre>
</blockquote>

<p>Download and install the latest release .deb package from the project repository:</p>

<blockquote>
  <pre>$ wget python3-recce7_1.0-1_all.deb
$ sudo dpkg -i python3-recce7_1.0-1_all.deb</pre>
</blockquote>

<p>While this will install the package, it will not automatically install the package's dependencies. To do this, run</p>

<blockquote>
  <pre>$ sudo apt-get install -f</pre>
</blockquote>

<p><b>Note: </b>During installation, the following error has been known to prevent the installation from completing:</p>

<blockquote>
  <pre>(Py3) Installing p0f API module...
Downloading/unpacking p0f
  Cannot fetch index base URL https://pypi.python.org/simple/
  Could not find any downloads that satisfy the requirement p0f
Cleaning up...
No distributions at all found for p0f
Storing debug log for failure in /home/ubuntu/.pip/pip.log
dpkg: error processing package python3-recce7 (--configure):
 subprocess installed post-installation script returned error exit status 1
Setting up blt (2.4z-7ubuntu2) ...
Setting up python3-tk (3.4.3-1~14.04.2) ...
Processing triggers for ca-certificates (20160104ubuntu0.14.04.1) ...
Updating certificates in /etc/ssl/certs... 173 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....done.
Processing triggers for libc-bin (2.19-0ubuntu6) ...
Processing triggers for ureadahead (0.100.0-16) ...
Errors were encountered while processing:
 python3-recce7
E: Sub-process /usr/bin/dpkg returned an error code (1)<pre>
</blockquote>

<p>This appears to be due to an upstream bug; to remedy the problem, rerun the following command and the installation
should complete successfully:</p>

<blockquote>
  <pre>$ sudo apt-get install -f</pre>
</blockquote>

<p>After installation you should edit your configuration files. An example configuration is installed by default but
you'll most likely want to edit the default settings to suit your needs. There are two configuration files located
in the <tt>/etc/recce7/configs</tt> directory after installation: <tt>global.cfg</tt> and <tt>plugins.cfg</tt>.</p>

<p>In the <tt>global.cfg</tt> file, you should set the following line to the main address of the network interface you would like
the honeypot to listen on (the address <tt>192.168.0.2</tt> is shown in the example):</p>

<blockquote>
  <pre>[Framework]
  .
  .
  .
listeningAddress = 192.168.0.2</pre>
</blockquote>

<p>If you leave this line blank (after the '=') the honeypot will listen on all interfaces by default.</p>

<p>Similarly, you can configure the reporting server to listen for connections on the desired address and port by editing
these lines:</p>

<blockquote>
  <pre>[ReportServer]
reportserver.host = 127.0.0.1
reportserver.port = 8080</pre>
</blockquote>

<p>In the <tt>plugins.cfg</tt> file you can configure the plugins you'd like to run. Each section in this file
describes one instance of a plugin. An example section looks like this:</p>

<blockquote>
  <pre>[MyHTTPInstance]
port = 80
table = http
module = http
moduleClass = HTTPPlugin
enabled = Yes
rawSocket = no
tableColumns = [[1,'command','TEXT'], [2,'path','TEXT'], [3, 'headers', 'TEXT'], [4, 'body', 'TEXT']]</pre>
</blockquote>

<p>This creates a new webserver plugin instance. The section header <tt>[HTTP]</tt> defines the instance's name; this can be
anything you'd like. The <tt>port</tt> line dictates which port the plugin will listen on. The <tt>module</tt> and <tt>moduleClass</tt>
lines can specify the type of plugin you wish to run. To create a webserver plugin instance, set the lines as follows:</p>

<blockquote><pre>module = http
moduleClass = HTTPPlugin</pre></blockquote>

<p>To create a telnet plugin instance, set the lines as follows:</p>

<blockquote><pre>module = telnet
moduleClass = TelnetPlugin</pre></blockquote>

<p>The <tt>table</tt> line will dictate the name of the table that this plugin instance will use.</p>

<p>A particular plugin type (e.g. http
or telnet) may have many running instances so long as they have unique names, unique table names and unique ports; this may be useful
for running an HTTP plugin on, for example, port 80, port 443, port 8080 or any other port you wish to use.

<p>The other lines should not need to be modified unless you plan to extend the functionality of the plugins (see below).</p>

<p><b>Note: </b>Plugins that listen on ports below 1024 will need to be enabled with authbind. When HunnyPotR/Recce7 is started, it drops
its permissions to the user <tt>nobody</tt> (and group <tt>nogroup</tt>) but retains the ability to listen on low-numbered
ports using the <tt>authbind</tt> command. Consult the <tt>authbind</tt> manual pages and follow the process to enable the
desired ports. Port numbers greater than 1024 do not need to be enabled through authbind. The ports used by the default plugin
configuration that ships with HunnyPotR/Recce7 will be enabled with authbind during installation.</p>

<h3><a id="installing-basemap" class="anchor" href="#installing-basemap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing Basemap</h3>

<p>If you wish to use the <tt>/worldmap</tt> reporting server endpoint (see above) you will need to install the Python 3 Basemap module, which is a part of the Matplotlib Python 3 kit. This is an involved process on a Raspberry Pi Zero as the Basemap plugin is quite hefty and requires a large quantity of RAM.</p>

<p>You should ensure that you have at least 4GB of storage available on your Raspberry Pi Zero before beginning this process.</p>

<p>It is recommended that you start by creating a swapfile that's at least 1500 MB in size. Consult the <tt>dphys-swapfile</tt> manpage on the Raspberry Pi for instructions on increasing the default swap file size on your system.</p>

<p>Next, download, build and install Basemap (<b>Note: </b>this process can take up to 2 hours to complete):</p>

<blockquote><pre>$ cd ~
$ wget https://github.com/matplotlib/basemap/archive/v1.0.7rel.tar.gz
$ tar zxvf v1.0.7rel.tar.gz
$ cd basemap-1.0.7rel/geos-3.3.3
$ export GEOS_DIR=/usr/local
$ ./configure --prefix=$GEOS_DIR
$ make
$ sudo make install
$ cd ../
$ sudo python3 setup.py install
$ sudo ldconfig</pre></blockquote>

<h1>
<a id="instructions-for-developing-plug-ins" class="anchor" href="#instructions-for-developing-plug-ins" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Instructions for Developing plug-ins</h1>

<h3>
<a id="config-file-entries" class="anchor" href="#config-file-entries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Config File Entries</h3>

<p><b>The configuration entry name.</b></p>
<tt>[(string)]</tt>
<p><b>The port number.</b> The value must lie in the range of 0 to 65535.</p>
<tt>port = (number)</tt>
<p><b>The database table name.</b>  This name must adhere to the SQL syntax for table names.</p>
<tt>table = (string)</tt>
<p><b>The module name.</b> This will be the name of the python module containing the plug-in class.</p>
<tt>module = (string)</tt>
<p><b>The class name.</b>  This is the name of the plug-in class.  This class must exists within the module specified by the module name.</p>
<tt>moduleClass = (string)</tt>
<p><b>Specifies if the plug-in is enabled.</b>If this field is set to no the framework will not spawn the listener for the port and no database table will be created.</p>
<tt>enabled = (Yes or No)</tt>
<p><b>Specifies if the socket is receiving raw packets.</b> This functionality is currently not implemented in the software.</p>
<tt>rawSocket = (Yes or No)</tt>
<p><b>The column indexes, headings, and data types to be interpreted as a Python array.</b> This row provides the parameters for building the dictionary to write plug-in data to the database.</p>
<tt>tableColumns = ([[column index, column heading, data type], ...]])</tt>

<p><b>Example Configuration</b></p>
<blockquote><pre>
[HTTP]
port = 8083
table = HTTP
module = http
moduleClass = HTTPPlugin
enabled = Yes
rawSocket = no
tableColumns = [[1,'command','TEXT'], [2,'path','TEXT'], [3, 'headers', 'TEXT'], [4, 'body', 'TEXT']]
</pre></blockquote>


<h2>
<a id="api" class="anchor" href="#api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API</h2>

<p>plug-ins will need to interact with our <em>Baseplug-in</em> so that the data can be inserted properly into the database.  There are two methods that plug-ins must implement.</p>

<h3>
<a id="do_trackself" class="anchor" href="#do_trackself" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>do_track(self):</h3>

<p>Do track will hold all of the logic in the plug-in that tracks what a user is doing and stores that information in local data structures that follow the data formatting that is described above.  This will differ for each service that is made into a plug-in.  For example we would not expect to see the same kind of attacks hitting a MySQL server as we would for an Apache Web Server.</p>

<h3>
<a id="get_sessionself" class="anchor" href="#get_sessionself" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>get_session(self):</h3>

<p>This method allows HoneyPotR to group attacks into sessions based on when an attacker connects until they disconnect.  The reason that this is not handled in the Baseplug-in is that some services natively allow session tracking.  An HTTP server may use cookies or HTTP Headers for tracking sessions while for Telnet we needed to implement a UUID for this.</p>

<h3>
<a id="get_sessionself" class="anchor" href="#get_sessionself" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>close_descriptors(self):</h3>
<p>This method will handle closing any file descriptors the plug-in has opened.  This method should be called at the end of the plug-in lifecycle.  This includes the natural end of the plug-in or premature end by exceptions.</p>

<h3>
<a id="get_sessionself" class="anchor" href="#get_sessionself" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>do_save(self):</h3>
<p>This method handles calling the framework to save data to the database.  A dictionary is constructed using the columns defined in the configuration.  The dictionary values are populated by matching the column names with attributes of the same name in the plug-in.  This populated dictionary is sent to the framework to be written to the database.</p>


<h2>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h2>

<p>Matt <a href="https://github.com/howard-roark" class="user-mention">@howard-roark</a>, Dina <a href="https://github.com/dsteeve" class="user-mention">@dsteeve</a>, Charlie <a href="https://github.com/belmontrevenge" class="user-mention">@belmontrevenge</a>, Ben <a href="https://github.com/benphillips989" class="user-mention">@benphillips989</a>, Jesse <a href="https://github.com/jnels124" class="user-mention">@jnels124</a>, Randy  <a href="https://github.com/rsoren514" class="user-mention">@rsoren514</a>, Zach
<a href="https://github.com/zkuhns" class="user-mention">@zkuhns</a></p>

<h2>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support or Contact</h2>

<p>Have questions or need support? Please contact any of the above contributors at their GitHub pages.</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
